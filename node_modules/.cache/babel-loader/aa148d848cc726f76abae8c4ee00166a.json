{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.propKey = propKey;\nexports.intersection = intersection;\nexports.createRuleSet = createRuleSet;\nexports.createClassName = createClassName;\nexports.castBreakpointsToIntegers = castBreakpointsToIntegers;\nexports.memoize = memoize;\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * Extracts the single breakpoint prop from the props object.\n */\n\n\nfunction propKey(breakpointProps) {\n  return Object.keys(breakpointProps)[0];\n}\n/**\n * Returns the intersection of two arrays.\n */\n\n\nfunction intersection(a1, a2) {\n  return a2 ? a1.filter(function (element) {\n    return a2.indexOf(element) >= 0;\n  }) : _toConsumableArray(a1);\n}\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\n\n\nfunction createRuleSet(className, query) {\n  return \"@media \".concat(query, \"{.\").concat(className, \"{display:none!important;}}\");\n}\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\n\n\nfunction createClassName() {\n  for (var _len = arguments.length, components = new Array(_len), _key = 0; _key < _len; _key++) {\n    components[_key] = arguments[_key];\n  }\n\n  return [\"fresnel\"].concat(_toConsumableArray(components.reduce(function (acc, breakpoint) {\n    return Array.isArray(breakpoint) ? _toConsumableArray(acc).concat(_toConsumableArray(breakpoint)) : _toConsumableArray(acc).concat([breakpoint]);\n  }, []))).join(\"-\");\n}\n/**\n * Returns an object with every values casted to integers.\n */\n\n\nfunction castBreakpointsToIntegers(breakpoints) {\n  var keys = Object.keys(breakpoints);\n  return keys.reduce(function (previous, current, currentIndex) {\n    return _objectSpread({}, previous, _defineProperty({}, keys[currentIndex], Math.round(Number(breakpoints[current]))));\n  }, {});\n}\n/**\n * Use this function to memoize any function\n */\n\n\nfunction memoize(func) {\n  var results = {};\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var argsKey = JSON.stringify(args);\n\n    if (!results[argsKey]) {\n      results[argsKey] = func.apply(void 0, args);\n    }\n\n    return results[argsKey];\n  };\n}","map":{"version":3,"sources":["../src/Utils.ts"],"names":["Object","a2","components","Array","keys","Math","Number","breakpoints","results","args","argsKey","JSON","func"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGA;AACA;AACA;;;AACO,SAAA,OAAA,CAAA,eAAA,EAAwD;EAC7D,OAAOA,MAAM,CAANA,IAAAA,CAAAA,eAAAA,EAAP,CAAOA,CAAP;AACD;AAED;AACA;AACA;;;AACO,SAAA,YAAA,CAAA,EAAA,EAAA,EAAA,EAGE;EACP,OAAOC,EAAE,GAAG,EAAE,CAAF,MAAA,CAAU,UAAA,OAAA,EAAO;IAAA,OAAIA,EAAE,CAAFA,OAAAA,CAAAA,OAAAA,KAAJ,CAAA;EAApB,CAAG,CAAH,GAAA,kBAAA,CAAT,EAAS,CAAT;AACD;AAED;AACA;AACA;AACA;;;AACO,SAAA,aAAA,CAAA,SAAA,EAAA,KAAA,EAAyD;EAC9D,OAAA,UAAA,MAAA,CAAA,KAAA,EAAA,IAAA,EAAA,MAAA,CAAA,SAAA,EAAA,4BAAA,CAAA;AACD;AAED;AACA;AACA;;;AACO,SAAA,eAAA,GAEL;EAAA,KAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EADGC,UACH,GAAA,IAAA,KAAA,CAAA,IAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;IADGA,UACH,CAAA,IAAA,CADGA,GACH,SAAA,CAAA,IAAA,CADGA;EACH;;EACA,OAAO,CAAA,SAAA,EAAA,MAAA,CAAA,kBAAA,CAEF,UAAU,CAAV,MAAA,CACD,UAAA,GAAA,EAAA,UAAA,EAAA;IAAA,OACEC,KAAK,CAALA,OAAAA,CAAAA,UAAAA,IAAAA,kBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,kBAAAA,CAAAA,UAAAA,CAAAA,CAAAA,GAAAA,kBAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,CAAAA,CADF,UACEA,CAAAA,CADF;EADC,CAAA,EAFE,EAEF,CAFE,CAAA,EAAA,IAAA,CAAP,GAAO,CAAP;AAUD;AAED;AACA;AACA;;;AACO,SAAA,yBAAA,CAAA,WAAA,EAEuB;EAC5B,IAAMC,IAAI,GAAGJ,MAAM,CAANA,IAAAA,CAAb,WAAaA,CAAb;EAEA,OAAO,IAAI,CAAJ,MAAA,CACL,UAAA,QAAA,EAAA,OAAA,EAAA,YAAA,EAAA;IAAA,OAAA,aAAA,CAAA,EAAA,EAAA,QAAA,EAAA,eAAA,CAAA,EAAA,EAEGI,IAAI,CAFP,YAEO,CAFP,EAEwBC,IAAI,CAAJA,KAAAA,CAAWC,MAAM,CAACC,WAAW,CAFrD,OAEqD,CAAZ,CAAjBF,CAFxB,CAAA,CAAA;EADK,CAAA,EAAP,EAAO,CAAP;AAOD;AAED;AACA;AACA;;;AACO,SAAA,OAAA,CAAA,IAAA,EAA8D;EACnE,IAAMG,OAAO,GAAb,EAAA;EACA,OAAO,YAAa;IAAA,KAAA,IAAA,KAAA,GAAA,SAAA,CAAA,MAAA,EAATC,IAAS,GAAA,IAAA,KAAA,CAAA,KAAA,CAAA,EAAA,KAAA,GAAA,CAAA,EAAA,KAAA,GAAA,KAAA,EAAA,KAAA,EAAA,EAAA;MAATA,IAAS,CAAA,KAAA,CAATA,GAAS,SAAA,CAAA,KAAA,CAATA;IAAS;;IAClB,IAAMC,OAAO,GAAGC,IAAI,CAAJA,SAAAA,CAAhB,IAAgBA,CAAhB;;IACA,IAAI,CAACH,OAAO,CAAZ,OAAY,CAAZ,EAAuB;MACrBA,OAAO,CAAPA,OAAO,CAAPA,GAAmBI,IAAI,CAAJA,KAAAA,CAAAA,KAAAA,CAAAA,EAAnBJ,IAAmBI,CAAnBJ;IACD;;IACD,OAAOA,OAAO,CAAd,OAAc,CAAd;EALF,CAAA;AAOD","sourcesContent":["import { MediaBreakpointProps } from \"./Media\"\nimport { BreakpointConstraintKey } from \"./Breakpoints\"\n\n/**\n * Extracts the single breakpoint prop from the props object.\n */\nexport function propKey(breakpointProps: MediaBreakpointProps) {\n  return Object.keys(breakpointProps)[0] as BreakpointConstraintKey\n}\n\n/**\n * Returns the intersection of two arrays.\n */\nexport function intersection(\n  a1: ReadonlyArray<any>,\n  a2?: ReadonlyArray<any>\n): any[] {\n  return a2 ? a1.filter(element => a2.indexOf(element) >= 0) : [...a1]\n}\n\n/**\n * Generate a style rule for a given class name that will hide the element\n * when the given query matches.\n */\nexport function createRuleSet(className: string, query: string) {\n  return `@media ${query}{.${className}{display:none!important;}}`\n}\n\n/**\n * Given a list of strings, or string tuples, generates a class name.\n */\nexport function createClassName(\n  ...components: Array<string | [string, string]>\n) {\n  return [\n    \"fresnel\",\n    ...components.reduce(\n      (acc: string[], breakpoint) =>\n        Array.isArray(breakpoint)\n          ? [...acc, ...breakpoint]\n          : [...acc, breakpoint],\n      []\n    ),\n  ].join(\"-\")\n}\n\n/**\n * Returns an object with every values casted to integers.\n */\nexport function castBreakpointsToIntegers(breakpoints: {\n  [key: string]: number | string\n}): { [key: string]: number } {\n  const keys = Object.keys(breakpoints)\n\n  return keys.reduce(\n    (previous, current, currentIndex) => ({\n      ...previous,\n      [keys[currentIndex]]: Math.round(Number(breakpoints[current])),\n    }),\n    {}\n  )\n}\n\n/**\n * Use this function to memoize any function\n */\nexport function memoize<F extends (...args: any[]) => void>(func: F) {\n  const results = {}\n  return (...args) => {\n    const argsKey = JSON.stringify(args)\n    if (!results[argsKey]) {\n      results[argsKey] = func(...args)\n    }\n    return results[argsKey]\n  }\n}\n"]},"metadata":{},"sourceType":"script"}