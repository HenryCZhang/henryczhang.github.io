{"ast":null,"code":"import { colorMix, getStyleFromHsl, getStyleFromRgb } from \"./ColorUtils\";\nexport function drawLine(context, begin, end) {\n  context.beginPath();\n  context.moveTo(begin.x, begin.y);\n  context.lineTo(end.x, end.y);\n  context.closePath();\n}\nexport function drawTriangle(context, p1, p2, p3) {\n  context.beginPath();\n  context.moveTo(p1.x, p1.y);\n  context.lineTo(p2.x, p2.y);\n  context.lineTo(p3.x, p3.y);\n  context.closePath();\n}\nexport function paintBase(context, dimension, baseColor) {\n  context.save();\n  context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n  context.fillRect(0, 0, dimension.width, dimension.height);\n  context.restore();\n}\nexport function clear(context, dimension) {\n  context.clearRect(0, 0, dimension.width, dimension.height);\n}\nexport function drawConnectLine(context, width, lineStyle, begin, end) {\n  context.save();\n  drawLine(context, begin, end);\n  context.lineWidth = width;\n  context.strokeStyle = lineStyle;\n  context.stroke();\n  context.restore();\n}\nexport function gradient(context, p1, p2, opacity) {\n  const gradStop = Math.floor(p2.getRadius() / p1.getRadius()),\n        color1 = p1.getFillColor(),\n        color2 = p2.getFillColor();\n\n  if (!color1 || !color2) {\n    return;\n  }\n\n  const sourcePos = p1.getPosition(),\n        destPos = p2.getPosition(),\n        midRgb = colorMix(color1, color2, p1.getRadius(), p2.getRadius()),\n        grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n  grad.addColorStop(0, getStyleFromHsl(color1, opacity));\n  grad.addColorStop(gradStop > 1 ? 1 : gradStop, getStyleFromRgb(midRgb, opacity));\n  grad.addColorStop(1, getStyleFromHsl(color2, opacity));\n  return grad;\n}\nexport function drawGrabLine(context, width, begin, end, colorLine, opacity) {\n  context.save();\n  drawLine(context, begin, end);\n  context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n  context.lineWidth = width;\n  context.stroke();\n  context.restore();\n}\nexport function drawParticle(container, context, particle, delta, colorStyles, backgroundMask, composite, radius, opacity, shadow) {\n  var _a, _b, _c, _d;\n\n  const pos = particle.getPosition(),\n        tiltOptions = particle.options.tilt,\n        rollOptions = particle.options.roll;\n  context.save();\n\n  if (tiltOptions.enable || rollOptions.enable) {\n    const roll = rollOptions.enable && particle.roll,\n          tilt = tiltOptions.enable && particle.tilt,\n          rollHorizontal = roll && (rollOptions.mode === \"horizontal\" || rollOptions.mode === \"both\"),\n          rollVertical = roll && (rollOptions.mode === \"vertical\" || rollOptions.mode === \"both\");\n    context.setTransform(rollHorizontal ? Math.cos(particle.roll.angle) : 1, tilt ? Math.cos(particle.tilt.value) * particle.tilt.cosDirection : 0, tilt ? Math.sin(particle.tilt.value) * particle.tilt.sinDirection : 0, rollVertical ? Math.sin(particle.roll.angle) : 1, pos.x, pos.y);\n  } else {\n    context.translate(pos.x, pos.y);\n  }\n\n  context.beginPath();\n  const angle = ((_b = (_a = particle.rotate) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + (particle.options.rotate.path ? particle.velocity.angle : 0);\n\n  if (angle !== 0) {\n    context.rotate(angle);\n  }\n\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n\n  const shadowColor = particle.shadowColor;\n\n  if (shadow.enable && shadowColor) {\n    context.shadowBlur = shadow.blur;\n    context.shadowColor = getStyleFromRgb(shadowColor);\n    context.shadowOffsetX = shadow.offset.x;\n    context.shadowOffsetY = shadow.offset.y;\n  }\n\n  if (colorStyles.fill) {\n    context.fillStyle = colorStyles.fill;\n  }\n\n  const stroke = particle.stroke;\n  context.lineWidth = (_c = particle.strokeWidth) !== null && _c !== void 0 ? _c : 0;\n\n  if (colorStyles.stroke) {\n    context.strokeStyle = colorStyles.stroke;\n  }\n\n  drawShape(container, context, particle, radius, opacity, delta);\n\n  if (((_d = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _d !== void 0 ? _d : 0) > 0) {\n    context.stroke();\n  }\n\n  if (particle.close) {\n    context.closePath();\n  }\n\n  if (particle.fill) {\n    context.fill();\n  }\n\n  context.restore();\n  context.save();\n\n  if (tiltOptions.enable && particle.tilt) {\n    context.setTransform(1, Math.cos(particle.tilt.value) * particle.tilt.cosDirection, Math.sin(particle.tilt.value) * particle.tilt.sinDirection, 1, pos.x, pos.y);\n  } else {\n    context.translate(pos.x, pos.y);\n  }\n\n  if (angle !== 0) {\n    context.rotate(angle);\n  }\n\n  if (backgroundMask) {\n    context.globalCompositeOperation = composite;\n  }\n\n  drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n  context.restore();\n}\nexport function drawShape(container, context, particle, radius, opacity, delta) {\n  if (!particle.shape) {\n    return;\n  }\n\n  const drawer = container.drawers.get(particle.shape);\n\n  if (!drawer) {\n    return;\n  }\n\n  drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n  if (!particle.shape) {\n    return;\n  }\n\n  const drawer = container.drawers.get(particle.shape);\n\n  if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n    return;\n  }\n\n  drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawPlugin(context, plugin, delta) {\n  if (!plugin.draw) {\n    return;\n  }\n\n  context.save();\n  plugin.draw(context, delta);\n  context.restore();\n}\nexport function drawParticlePlugin(context, plugin, particle, delta) {\n  if (!plugin.drawParticle) {\n    return;\n  }\n\n  context.save();\n  plugin.drawParticle(context, particle, delta);\n  context.restore();\n}\nexport function drawEllipse(context, particle, fillColorValue, radius, opacity, width, rotation, start, end) {\n  if (width <= 0) {\n    return;\n  }\n\n  const pos = particle.getPosition();\n\n  if (fillColorValue) {\n    context.strokeStyle = getStyleFromHsl(fillColorValue, opacity);\n  }\n\n  context.lineWidth = width;\n  const rotationRadian = rotation * Math.PI / 180;\n  context.beginPath();\n  context.ellipse(pos.x, pos.y, radius / 2, radius * 2, rotationRadian, start, end);\n  context.stroke();\n}\nexport function alterHsl(color, type, value) {\n  return {\n    h: color.h,\n    s: color.s,\n    l: color.l + (type === \"darken\" ? -1 : 1) * value\n  };\n}","map":{"version":3,"names":["colorMix","getStyleFromHsl","getStyleFromRgb","drawLine","context","begin","end","beginPath","moveTo","x","y","lineTo","closePath","drawTriangle","p1","p2","p3","paintBase","dimension","baseColor","save","fillStyle","fillRect","width","height","restore","clear","clearRect","drawConnectLine","lineStyle","lineWidth","strokeStyle","stroke","gradient","opacity","gradStop","Math","floor","getRadius","color1","getFillColor","color2","sourcePos","getPosition","destPos","midRgb","grad","createLinearGradient","addColorStop","drawGrabLine","colorLine","drawParticle","container","particle","delta","colorStyles","backgroundMask","composite","radius","shadow","_a","_b","_c","_d","pos","tiltOptions","options","tilt","rollOptions","roll","enable","rollHorizontal","mode","rollVertical","setTransform","cos","angle","value","cosDirection","sin","sinDirection","translate","rotate","path","velocity","globalCompositeOperation","shadowColor","shadowBlur","blur","shadowOffsetX","offset","shadowOffsetY","fill","strokeWidth","drawShape","close","drawShapeAfterEffect","shape","drawer","drawers","get","draw","retina","pixelRatio","afterEffect","drawPlugin","plugin","drawParticlePlugin","drawEllipse","fillColorValue","rotation","start","rotationRadian","PI","ellipse","alterHsl","color","type","h","s","l"],"sources":["/Users/zhangcao/Desktop/ZhangCao_Henry_Portfolio/node_modules/tsparticles-engine/esm/Utils/CanvasUtils.js"],"sourcesContent":["import { colorMix, getStyleFromHsl, getStyleFromRgb } from \"./ColorUtils\";\nexport function drawLine(context, begin, end) {\n    context.beginPath();\n    context.moveTo(begin.x, begin.y);\n    context.lineTo(end.x, end.y);\n    context.closePath();\n}\nexport function drawTriangle(context, p1, p2, p3) {\n    context.beginPath();\n    context.moveTo(p1.x, p1.y);\n    context.lineTo(p2.x, p2.y);\n    context.lineTo(p3.x, p3.y);\n    context.closePath();\n}\nexport function paintBase(context, dimension, baseColor) {\n    context.save();\n    context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n    context.fillRect(0, 0, dimension.width, dimension.height);\n    context.restore();\n}\nexport function clear(context, dimension) {\n    context.clearRect(0, 0, dimension.width, dimension.height);\n}\nexport function drawConnectLine(context, width, lineStyle, begin, end) {\n    context.save();\n    drawLine(context, begin, end);\n    context.lineWidth = width;\n    context.strokeStyle = lineStyle;\n    context.stroke();\n    context.restore();\n}\nexport function gradient(context, p1, p2, opacity) {\n    const gradStop = Math.floor(p2.getRadius() / p1.getRadius()), color1 = p1.getFillColor(), color2 = p2.getFillColor();\n    if (!color1 || !color2) {\n        return;\n    }\n    const sourcePos = p1.getPosition(), destPos = p2.getPosition(), midRgb = colorMix(color1, color2, p1.getRadius(), p2.getRadius()), grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n    grad.addColorStop(0, getStyleFromHsl(color1, opacity));\n    grad.addColorStop(gradStop > 1 ? 1 : gradStop, getStyleFromRgb(midRgb, opacity));\n    grad.addColorStop(1, getStyleFromHsl(color2, opacity));\n    return grad;\n}\nexport function drawGrabLine(context, width, begin, end, colorLine, opacity) {\n    context.save();\n    drawLine(context, begin, end);\n    context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n    context.lineWidth = width;\n    context.stroke();\n    context.restore();\n}\nexport function drawParticle(container, context, particle, delta, colorStyles, backgroundMask, composite, radius, opacity, shadow) {\n    var _a, _b, _c, _d;\n    const pos = particle.getPosition(), tiltOptions = particle.options.tilt, rollOptions = particle.options.roll;\n    context.save();\n    if (tiltOptions.enable || rollOptions.enable) {\n        const roll = rollOptions.enable && particle.roll, tilt = tiltOptions.enable && particle.tilt, rollHorizontal = roll && (rollOptions.mode === \"horizontal\" || rollOptions.mode === \"both\"), rollVertical = roll && (rollOptions.mode === \"vertical\" || rollOptions.mode === \"both\");\n        context.setTransform(rollHorizontal ? Math.cos(particle.roll.angle) : 1, tilt ? Math.cos(particle.tilt.value) * particle.tilt.cosDirection : 0, tilt ? Math.sin(particle.tilt.value) * particle.tilt.sinDirection : 0, rollVertical ? Math.sin(particle.roll.angle) : 1, pos.x, pos.y);\n    }\n    else {\n        context.translate(pos.x, pos.y);\n    }\n    context.beginPath();\n    const angle = ((_b = (_a = particle.rotate) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : 0) + (particle.options.rotate.path ? particle.velocity.angle : 0);\n    if (angle !== 0) {\n        context.rotate(angle);\n    }\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    const shadowColor = particle.shadowColor;\n    if (shadow.enable && shadowColor) {\n        context.shadowBlur = shadow.blur;\n        context.shadowColor = getStyleFromRgb(shadowColor);\n        context.shadowOffsetX = shadow.offset.x;\n        context.shadowOffsetY = shadow.offset.y;\n    }\n    if (colorStyles.fill) {\n        context.fillStyle = colorStyles.fill;\n    }\n    const stroke = particle.stroke;\n    context.lineWidth = (_c = particle.strokeWidth) !== null && _c !== void 0 ? _c : 0;\n    if (colorStyles.stroke) {\n        context.strokeStyle = colorStyles.stroke;\n    }\n    drawShape(container, context, particle, radius, opacity, delta);\n    if (((_d = stroke === null || stroke === void 0 ? void 0 : stroke.width) !== null && _d !== void 0 ? _d : 0) > 0) {\n        context.stroke();\n    }\n    if (particle.close) {\n        context.closePath();\n    }\n    if (particle.fill) {\n        context.fill();\n    }\n    context.restore();\n    context.save();\n    if (tiltOptions.enable && particle.tilt) {\n        context.setTransform(1, Math.cos(particle.tilt.value) * particle.tilt.cosDirection, Math.sin(particle.tilt.value) * particle.tilt.sinDirection, 1, pos.x, pos.y);\n    }\n    else {\n        context.translate(pos.x, pos.y);\n    }\n    if (angle !== 0) {\n        context.rotate(angle);\n    }\n    if (backgroundMask) {\n        context.globalCompositeOperation = composite;\n    }\n    drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n    context.restore();\n}\nexport function drawShape(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n        return;\n    }\n    const drawer = container.drawers.get(particle.shape);\n    if (!drawer) {\n        return;\n    }\n    drawer.draw(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n    if (!particle.shape) {\n        return;\n    }\n    const drawer = container.drawers.get(particle.shape);\n    if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n        return;\n    }\n    drawer.afterEffect(context, particle, radius, opacity, delta, container.retina.pixelRatio);\n}\nexport function drawPlugin(context, plugin, delta) {\n    if (!plugin.draw) {\n        return;\n    }\n    context.save();\n    plugin.draw(context, delta);\n    context.restore();\n}\nexport function drawParticlePlugin(context, plugin, particle, delta) {\n    if (!plugin.drawParticle) {\n        return;\n    }\n    context.save();\n    plugin.drawParticle(context, particle, delta);\n    context.restore();\n}\nexport function drawEllipse(context, particle, fillColorValue, radius, opacity, width, rotation, start, end) {\n    if (width <= 0) {\n        return;\n    }\n    const pos = particle.getPosition();\n    if (fillColorValue) {\n        context.strokeStyle = getStyleFromHsl(fillColorValue, opacity);\n    }\n    context.lineWidth = width;\n    const rotationRadian = (rotation * Math.PI) / 180;\n    context.beginPath();\n    context.ellipse(pos.x, pos.y, radius / 2, radius * 2, rotationRadian, start, end);\n    context.stroke();\n}\nexport function alterHsl(color, type, value) {\n    return {\n        h: color.h,\n        s: color.s,\n        l: color.l + (type === \"darken\" ? -1 : 1) * value,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}